/**
 * @file info.h
 * @author Chenxi Zhou
 * @brief all Info / Sample structs
 * @version 0.1
 * @date 2022-10-22
 * 
 * @copyright Copyright (c) 2022
 * 
 */
#pragma once

#include <variant>
#include <optional>

#include <core/geometry/geometry.h>
#include <core/render-core/spectrum.h>
#include <core/shape/shape.h>

class Scene;

//* This stores the information of the surface-ray intersection
struct SurfaceIntersectionInfo {
    //* Optional, if the ray hit environment, shape will be nullptr
    ShapeInterface  *shape = nullptr;
    //* Optional, depends on whether hit an emitter
    std::shared_ptr<Emitter> light;
    //* Position of the hitpoint, the same with vertex in PathInfo
    Point3f         position;
    //* Distance between the hitpoint and ray.ori
    float           distance;
    //* Direction of the wi(towards camera)
    Vector3f        wi;
    //* Geometry normal of the hitpoint
    Normal3f        geometryNormal;
    //* The local shading frame of the hitpoint
    Frame           shadingFrame;
    //* The uv coordinate of the hitpoint
    Point2f         uv;

    operator bool() const {return shape != nullptr;}
    Ray3f generateShadowRay(const Scene &scene, const LightSourceInfo &info) const;
    Ray3f generateRay(const Scene &scene, Vector3f dir) const;
    Vector3f toLocal(Vector3f v) const;
    Vector3f toWorld(Vector3f v) const;
};

//*   This stores the information of the medium-ray intersection, 
//* which is not generated by GeometryIntersection engine, it's usually generated by
//* sampling a point in the medium
struct MediumIntersectionInfo {

};

//*   Currently, There are two kinds of intersections can be held in rendering,
//* surface intersection and medium intersection
struct IntersectionInfo {
    IntersectionInfo() = default;
    IntersectionInfo(const SurfaceIntersectionInfo &sIts);
    IntersectionInfo(const MediumIntersectionInfo &mIts);

    const SurfaceIntersectionInfo* asSurfaceIntersection() const;
    const MediumIntersectionInfo* asMediumIntersection() const;

private:
    using Intersection = std::variant<SurfaceIntersectionInfo,
                                      MediumIntersectionInfo>;
    Intersection data;
};

//*   In path-tracing, we usually sample a new path vertex based on the previous one,
//* the sampled path has its weight (to the final contribution) and pdf (in solid angle x distance measure)
struct PathInfo {
    //* The position of the new path vertex
    Point3f     vertex;
    //* The length of this path segment
    float       length;
    //* The weight of the sampled new path vertex
    SpectrumRGB weight;
    //* The pdf of sampling the path direction
    float       pdfDirection;
    //* The pdf of sampling the path length
    float       pdfLength;
    //* The scatter information on new path vertex
    IntersectionInfo itsInfo;

    float pdf() const;    
};


//*   When sampling, all light sources in scene will be represented
//* as a luminous point, this struct is used to hide the differences
//* between different lightsources.
struct LightSourceInfo {
    enum LightType {
        Unknown = 0,
        Area,
        Spot,
        Environment
    } lightType;

    //* The light source
    const Emitter   *light;
    //* The position of the lumin point 
    Point3f         position;  
    //* Optional, normal at the lumin point
    Normal3f        normal;
    //* Direction, from path vertex to luminous point
    Vector3f        direction;
    //* The pdf of the sampling result
    //* If pdf == inf, it represents sampling a Dirac delta distribution
    float           pdf;        
};


struct BSDFInfo {
    SpectrumRGB weight;

    Vector3f    wo;

    float       pdf;
};

